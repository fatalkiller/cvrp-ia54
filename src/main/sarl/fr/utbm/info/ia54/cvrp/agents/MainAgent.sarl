package fr.utbm.info.ia54.cvrp.agents

import fr.utbm.info.ia54.cvrp.view.Display
import io.sarl.core.AgentTask
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.Schedules
import java.util.List
import fr.utbm.info.ia54.cvrp.model.Environment
import fr.utbm.info.ia54.cvrp.model.Metrics
import fr.utbm.info.ia54.cvrp.model.Road

// Don't write over occurrences
// Handle synchronization issues with synchronized() when needed
@SuppressWarnings("discouraged_occurrence_readonly_use", "potential_field_synchronization_problem")
agent MainAgent {
	
	var env : Environment; // Stores the position of the objects in the simulation
	var disp : Display; // Handles the view
	var met : Metrics; // Stores information on the simulation
	
	// Launching options
	var type : String
	var map : String
	var isDebugMode : Boolean
	
	// constants
	var simultaneousAgents : Integer
	var evaporationProportion : Float
	var evaporationConstant : Float
	var pheromoneInfluence : Float
	var distanceInfluence : Float

	uses Logging, Lifecycle, Schedules

	// I'm importing a String, toString is not inefficient
	@SuppressWarnings("potential_inefficient_value_conversion")
	on Initialize {
		loggingName = "Main Agent"
		info("Main agent spawned !");
		// Retrieve passed parameters like so
		type = occurrence.parameters.get(0) as String;
		map = occurrence.parameters.get(1) as String;
		simultaneousAgents = occurrence.parameters.get(2) as Integer;
		evaporationProportion = occurrence.parameters.get(3) as Float;
		evaporationConstant = occurrence.parameters.get(4) as Float;
		pheromoneInfluence = occurrence.parameters.get(5) as Float;
		distanceInfluence = occurrence.parameters.get(6) as Float;
		isDebugMode = occurrence.parameters.get(7) as Boolean;
		info(type)
		info(map)
		info(isDebugMode)

		env = new Environment(type, map, evaporationProportion, evaporationConstant);
		met = new Metrics(type, env, simultaneousAgents);

		info("Environment initialized.");

		disp = new Display(env, met, isDebugMode);

		// Find a way to transfer the stage from StartWindow to here
		info("Display initialized.");

		disp.changeDisplayFrameTitle("Ant colony");

		// I guess we just want the visuals to update and we want the agents to update ASAP and not wait for next frame
		// So Im making 2 loops, altho agents arent as much a loop as they are a nonstop exchange
		info("Displaying...");
		displayLoop();

		info("Starting to loop...")
		startAgents();
	}

	def displayLoop() : void {
		var framerate : int = 60;
		val taskMain : AgentTask = task("Main Loop")
		// Stuff to do every frame :
		taskMain.every(1000 / framerate) [

			disp.displaySimulationFrame();

		]
	}

	// Starts a new round
	def startAgents() : void {
		if (type.equals("TSP")) {
			for (startCity : env.getCities()) {
				met.increaseActiveAgents();
				spawn(TravelerAgent, env, met, startCity, type, isDebugMode);
			}
		}
		if (type.equals("CVRP")) {
			var i : Integer;
			for(i=0;i<simultaneousAgents;i++)
			{
				met.increaseActiveAgents();
				spawn(TravelerAgent, env, met, env.getCities().get(0), type, pheromoneInfluence, distanceInfluence, isDebugMode);
			}
		}
	}

	// Records the result of a finished agent
	on TravelsFinished {
		met.decreaseActiveAgents();
		var pathTaken : List<Road> = occurrence.pathTaken;
		var timeTaken : Long = occurrence.timeTaken;

		if (met.fastestTime.equals("TBD") || timeTaken < met.fastestTime.longValue) {
			if (isDebugMode) {
				info("new record!")
			}
			synchronized (met) {
				met.fastestTime = timeTaken.toString();
				met.formattedFastestPath = pathTaken;
			}
		}

		for (road : pathTaken) {
			//TODO : make futureweight an atomic type cus chances are, this is gonna get concurrent access
			road.increaseFutureWeight(timeTaken);
		}

		// Updates weights & starts a new round
		// We assume by the time an agent gets there, more have been spawned if planned
		if (met.activeAgents == 0) {
			met.increaseElapsedRounds();
			env.updateWeights();
			if (isDebugMode) {
				info("New round")
			}
			startAgents();
		}
	}

	on ExitApplicationEvent {
		killMe;
	}

	on Destroy {
		info("The main agent has stopped.")
	}
}
